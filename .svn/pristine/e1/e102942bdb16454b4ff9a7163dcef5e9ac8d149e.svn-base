/*
 * (c) 2022 Bodo Zunker. All rights reserved.
 * created 14.02.2022
 */
package bzr.demo.concurrency.examples;

import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * @author bodo
 *
 */
public class MasterClass
{
	public static final int POOL_SIZE = 10;
	public static final int TEST_SIZE = 1;
	public static final int REPEAT_COUNT = 1000;

	public static void main( final String[] args )
	{

		runTests();
	}

	static void runTests()
	{
		ExecutorService pool = Executors.newFixedThreadPool( POOL_SIZE );
		for( int i = 0; i < POOL_SIZE; i++ )
		{
			pool.submit( () -> {
				try
				{
					Thread.sleep( 10, 100 );
				}catch( InterruptedException e )
				{
					Thread.currentThread().interrupt();
				}
			} );

		}

		ComplexState complexStateInstance = new ComplexState();
		ArrayList<Future<?>> futures = new ArrayList<>();
		Logger.info( "" );

		Logger.info( "happilyNaive" );
		for( int i = 0; i < TEST_SIZE; i++ )
		{
			futures.add( pool.submit( complexStateInstance::happilyNaive ) );
		}
		Logger.info( "inbetween: " + complexStateInstance.atomicCounter.get() );

		// waitForFuture();

		Logger.info( "result: " + complexStateInstance.atomicCounter.get() );
		// assertEquals( TEST_SIZE * REPEAT_COUNT,
		// complexStateInstance.atomicCounter.get() );

		Logger.info( "butNowWe'reSaveRight" );
		for( int i = 0; i < TEST_SIZE; i++ )
		{
			futures.add( pool.submit( complexStateInstance::butNowWereSaveRight ) );
		}
		Logger.info( "inbetween: " + complexStateInstance.atomicCounter.get() );

		// waitForFuture();

		Logger.info( "result: " + complexStateInstance.atomicCounter.get() );
		// assertEquals( TEST_SIZE * REPEAT_COUNT,
		// complexStateInstance.atomicCounter.get() );

		Logger.info( "hasToWorkFinally" );
		for( int i = 0; i < TEST_SIZE; i++ )
		{
			futures.add( pool.submit( complexStateInstance::hasToWorkFinally ) );
		}
		Logger.info( "inbetween: " + complexStateInstance.atomicCounter.get() );

		// waitForFuture();

		Logger.info( "result: " + complexStateInstance.atomicCounter.get() );
		// assertEquals( TEST_SIZE * REPEAT_COUNT,
		// complexStateInstance.atomicCounter.get() );

		Logger.info( "localOnly" );
		for( int i = 0; i < TEST_SIZE; i++ )
		{
			futures.add( pool.submit( complexStateInstance::localOnly ) );
		}
		Logger.info( "inbetween: " + complexStateInstance.atomicCounter.get() );

		// waitForFuture();

		Logger.info( "result: " + complexStateInstance.atomicCounter.get() );
		// assertEquals( TEST_SIZE * REPEAT_COUNT,
		// complexStateInstance.atomicCounter.get() );
	}

}
